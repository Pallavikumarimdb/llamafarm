/**
 * AUTO-GENERATED - DO NOT EDIT
 * Generated from rag/schema.yaml by designer/generate-types.ts
 */

// ============================================================================
// Vector Store Config Interfaces (generated by json-schema-to-typescript)
// ============================================================================

export interface ChromaStoreConfig {
  /**
   * Collection name
   */
  collection_name?: string;
  /**
   * Server host
   */
  host?: string | null;
  /**
   * Server port
   */
  port?: number;
  /**
   * Distance metric
   */
  distance_function?: 'cosine' | 'l2' | 'ip';
  /**
   * Alternative distance metric name
   */
  distance_metric?: 'cosine' | 'l2' | 'ip';
  /**
   * Embedding dimension
   */
  embedding_dimension?: number;
  /**
   * Enable document deduplication
   */
  enable_deduplication?: boolean;
  /**
   * Built-in embedding function
   */
  embedding_function?: string | null;
}

export interface FaissStoreConfig {
  /**
   * Vector dimension
   */
  dimension: number;
  /**
   * Index type
   */
  index_type?: 'Flat' | 'IVF' | 'HNSW' | 'LSH';
  /**
   * Distance metric
   */
  metric?: 'L2' | 'IP' | 'Cosine';
  /**
   * Number of clusters (IVF)
   */
  nlist?: number;
  /**
   * Clusters to search (IVF)
   */
  nprobe?: number;
  /**
   * Enable GPU acceleration
   */
  use_gpu?: boolean;
}

export interface PineconeStoreConfig {
  /**
   * Pinecone API key
   */
  api_key: string;
  /**
   * Pinecone environment
   */
  environment?: string;
  /**
   * Index name
   */
  index_name: string;
  /**
   * Vector dimension
   */
  dimension: number;
  /**
   * Distance metric
   */
  metric?: 'euclidean' | 'cosine' | 'dotproduct';
  /**
   * Namespace for isolation
   */
  namespace?: string;
  /**
   * Number of replicas
   */
  replicas?: number;
}

export interface QdrantStoreConfig {
  /**
   * Server host
   */
  host?: string;
  /**
   * Server port
   */
  port?: number;
  /**
   * gRPC port
   */
  grpc_port?: number;
  /**
   * API key
   */
  api_key?: string | null;
  /**
   * Collection name
   */
  collection_name?: string;
  /**
   * Vector dimension
   */
  vector_size: number;
  /**
   * Distance metric
   */
  distance?: 'Cosine' | 'Euclid' | 'Dot';
  /**
   * Store vectors on disk
   */
  on_disk?: boolean;
}

// ============================================================================
// Embedder Config Interfaces (generated by json-schema-to-typescript)
// ============================================================================

export interface UniversalEmbedderConfig {
  /**
   * HuggingFace model ID
   */
  model?: string;
  /**
   * Ollama API endpoint (preferred)
   */
  base_url?: string;
  /**
   * Embedding dimension
   */
  dimension?: number;
  /**
   * Batch processing size
   */
  batch_size?: number;
  /**
   * Request timeout (seconds)
   */
  timeout?: number;
}

export interface OllamaEmbedderConfig {
  /**
   * Ollama model name
   */
  model?: string;
  /**
   * Ollama API endpoint (preferred)
   */
  base_url?: string;
  /**
   * Embedding dimension
   */
  dimension?: number;
  /**
   * Batch processing size
   */
  batch_size?: number;
  /**
   * Request timeout (seconds)
   */
  timeout?: number;
  /**
   * Auto-pull missing models
   */
  auto_pull?: boolean;
}

export interface HuggingfaceEmbedderConfig {
  /**
   * HuggingFace model ID
   */
  model_name?: string;
  /**
   * Computation device
   */
  device?: 'cpu' | 'cuda' | 'mps' | 'auto';
  /**
   * Batch size
   */
  batch_size?: number;
  /**
   * L2 normalize embeddings
   */
  normalize_embeddings?: boolean;
  /**
   * Show progress bar
   */
  show_progress_bar?: boolean;
  /**
   * Model cache directory
   */
  cache_folder?: string | null;
}

export interface OpenaiEmbedderConfig {
  /**
   * OpenAI embedding model
   */
  model?: string;
  /**
   * OpenAI API key
   */
  api_key?: string;
  /**
   * OpenAI API base URL
   */
  base_url?: string | null;
  /**
   * OpenAI organization ID
   */
  organization?: string | null;
  /**
   * Batch size for API calls
   */
  batch_size?: number;
  /**
   * Maximum retry attempts
   */
  max_retries?: number;
  /**
   * Request timeout in seconds
   */
  timeout?: number;
}

export interface SentenceTransformerConfig {
  /**
   * Model name
   */
  model_name?: string;
  /**
   * Computation device
   */
  device?: 'cpu' | 'cuda' | 'mps';
}

// ============================================================================
// Retrieval Strategy Config Interfaces (generated by json-schema-to-typescript)
// ============================================================================

export interface BasicSimilarityConfig {
  /**
   * Number of results
   */
  top_k?: number;
  /**
   * Distance metric
   */
  distance_metric?: 'cosine' | 'euclidean' | 'manhattan' | 'dot';
  /**
   * Minimum similarity score
   */
  score_threshold?: number | null;
}

export interface MetadataFilteredConfig {
  /**
   * Number of results
   */
  top_k?: number;
  /**
   * Metadata filters
   */
  filters?: {
    [k: string]: string | number | boolean | (string | number | boolean)[];
  };
  /**
   * When to apply filters
   */
  filter_mode?: 'pre' | 'post';
  /**
   * Multiplier for post-filtering
   */
  fallback_multiplier?: number;
}

export interface MultiQueryConfig {
  /**
   * Number of query variations
   */
  num_queries?: number;
  /**
   * Results per query
   */
  top_k?: number;
  /**
   * Result aggregation method
   */
  aggregation_method?: 'max' | 'mean' | 'weighted' | 'reciprocal_rank';
  /**
   * Weights for each query
   */
  query_weights?: number[] | null;
}

export interface RerankedConfig {
  /**
   * Initial candidates
   */
  initial_k?: number;
  /**
   * Final results
   */
  final_k?: number;
  /**
   * Reranking factor weights
   */
  rerank_factors?: {
    similarity_weight?: number;
    recency_weight?: number;
    length_weight?: number;
    metadata_weight?: number;
  };
  /**
   * Normalize scores before combining
   */
  normalize_scores?: boolean;
}

export interface HybridUniversalConfig {
  /**
   * Sub-strategies to combine
   *
   * @minItems 2
   * @maxItems 5
   */
  strategies?:
    | [
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        },
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        }
      ]
    | [
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        },
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        },
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        }
      ]
    | [
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        },
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        },
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        },
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        }
      ]
    | [
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        },
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        },
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        },
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        },
        {
          type: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy' | 'MultiQueryStrategy' | 'RerankedStrategy';
          weight?: number;
          config?: {
            [k: string]: unknown;
          };
        }
      ];
  /**
   * Combination method
   */
  combination_method?: 'weighted_average' | 'rank_fusion' | 'score_fusion';
  /**
   * Final number of results
   */
  final_k?: number;
}

/**
 * Cross-encoder reranking configuration using Universal Runtime with HuggingFace models
 */
export interface CrossEncoderRerankedConfig {
  /**
   * Name of the model from runtime.models to use for reranking (e.g., 'reranker')
   */
  model_name: string;
  /**
   * Number of initial candidates to retrieve before reranking
   */
  initial_k?: number;
  /**
   * Number of results to return after reranking
   */
  final_k?: number;
  /**
   * Base retrieval strategy to use for initial retrieval
   */
  base_strategy?: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy';
  /**
   * Configuration for the base strategy
   */
  base_strategy_config?: {
    [k: string]: unknown;
  };
  /**
   * Minimum relevance score (0-1) to include a result
   */
  relevance_threshold?: number;
  /**
   * Request timeout in seconds for reranking API calls
   */
  timeout?: number;
}

/**
 * Multi-turn RAG with query decomposition for complex queries
 */
export interface MultiTurnRAGConfig {
  /**
   * Name of the model from runtime.models to use for query decomposition (e.g., 'default')
   */
  model_name: string;
  /**
   * Optional API key for authentication. Defaults to OPENAI_API_KEY env var or 'not-needed' for local endpoints like Ollama
   */
  api_key?: string;
  /**
   * Maximum number of sub-queries to generate from decomposition
   */
  max_sub_queries?: number;
  /**
   * Minimum query length (characters) to trigger decomposition
   */
  complexity_threshold?: number;
  /**
   * Minimum length for each sub-query
   */
  min_query_length?: number;
  /**
   * Base retrieval strategy to use for each sub-query
   */
  base_strategy?: 'BasicSimilarityStrategy' | 'MetadataFilteredStrategy';
  /**
   * Configuration for the base strategy
   */
  base_strategy_config?: {
    [k: string]: unknown;
  };
  /**
   * Number of results to retrieve per sub-query
   */
  sub_query_top_k?: number;
  /**
   * Number of results to return after merging and deduplication
   */
  final_top_k?: number;
  /**
   * Enable reranking for each sub-query (slower but more accurate)
   */
  enable_reranking?: boolean;
  /**
   * Reranking strategy to use if reranking is enabled
   */
  reranker_strategy?: string;
  /**
   * Configuration for the reranking strategy
   */
  reranker_config?: {
    [k: string]: unknown;
  };
  /**
   * Similarity threshold for deduplication (0-1, higher = stricter)
   */
  dedup_similarity_threshold?: number;
  /**
   * Maximum parallel workers for sub-query retrieval
   */
  max_workers?: number;
}

// ============================================================================
// Type Constants
// ============================================================================

export const VECTOR_STORE_TYPES = ["ChromaStore","FAISSStore","PineconeStore","QdrantStore"] as const
export type VectorStoreType = typeof VECTOR_STORE_TYPES[number]

export const EMBEDDER_TYPES = ["OllamaEmbedder","HuggingFaceEmbedder","OpenAIEmbedder","SentenceTransformerEmbedder","UniversalEmbedder"] as const
export type EmbedderType = typeof EMBEDDER_TYPES[number]

export const RETRIEVAL_STRATEGY_TYPES = ["VectorRetriever","HybridRetriever","BM25Retriever","RerankedRetriever","GraphRetriever","ElasticRetriever","BasicSimilarityStrategy","MetadataFilteredStrategy","MultiQueryStrategy","RerankedStrategy","HybridUniversalStrategy","CrossEncoderRerankedStrategy","MultiTurnRAGStrategy"] as const
export type RetrievalStrategyType = typeof RETRIEVAL_STRATEGY_TYPES[number]
